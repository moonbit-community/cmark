package rami3l/cmark/cmark

alias @moonbitlang/core/buffer as @buffer
alias @moonbitlang/core/immut/list as @list
alias @moonbitlang/core/immut/sorted_map as @sorted_map
alias @moonbitlang/core/json as @json
alias @rami3l/cmark/cmark_base as @cmark_base

// Values
let layout_empty : Node[String]

fn layout_of_string(meta~ : @cmark_base.Meta = .., String) -> Node[String]

// Types and methods
type Atx
impl Atx {
  to_json(Self) -> Json
  to_string(Self) -> String
}
impl Show for Atx
impl ToJson for Atx

type BState
impl BState {
  op_equal(Self, Self) -> Bool
}
impl Eq for BState

pub enum Block {
  BlankLine(Node[String])
  BlockQuote(Node[BlockQuote])
  Blocks(Node[@list.T[Block]])
  CodeBlock(Node[CodeBlock])
  Heading(Node[BlockHeading])
  HtmlBlock(Node[HtmlBlock])
  LinkRefDefinition(Node[LinkDefinition])
  List(Node[BlockList])
  Paragraph(Node[BlockParagraph])
  ThematicBreak(Node[BlockThematicBreak])
  ExtTable(Node[Table])
  ExtFootnoteDefinition(Node[Footnote])
}
impl Block {
  defs(Self, init~ : @sorted_map.T[String, LabelDef] = ..) -> @sorted_map.T[String, LabelDef]
  empty() -> Self
  from_json(Json, @json.JsonPath) -> Self!@json.JsonDecodeError
  meta(Self) -> @cmark_base.Meta
  normalize(Self) -> Self
  to_json(Self) -> Json
  to_string(Self) -> String
}
impl Show for Block
impl ToJson for Block
impl @json.FromJson for Block

pub struct BlockHeading {
  pub layout : BlockHeadingLayout
  pub level : Int
  pub inline : Inline
  pub id : BlockHeadingId?
}
impl BlockHeading {
  from_json(Json, @json.JsonPath) -> Self!@json.JsonDecodeError
  new(id~ : BlockHeadingId? = .., layout~ : BlockHeadingLayout = .., level~ : Int, Inline) -> Self
  to_json(Self) -> Json
  to_string(Self) -> String
}
impl Show for BlockHeading
impl ToJson for BlockHeading
impl @json.FromJson for BlockHeading

pub struct BlockHeadingAtxLayout {
  pub indent : Int
  pub after_opening : String
  pub closing : String
}
impl BlockHeadingAtxLayout {
  default() -> Self
  from_json(Json, @json.JsonPath) -> Self!@json.JsonDecodeError
  to_json(Self) -> Json
  to_string(Self) -> String
}
impl Show for BlockHeadingAtxLayout
impl ToJson for BlockHeadingAtxLayout
impl @json.FromJson for BlockHeadingAtxLayout

pub enum BlockHeadingId {
  Auto(String)
  Id(String)
}
impl BlockHeadingId {
  from_json(Json, @json.JsonPath) -> Self!@json.JsonDecodeError
  to_json(Self) -> Json
  to_string(Self) -> String
}
impl Show for BlockHeadingId
impl ToJson for BlockHeadingId
impl @json.FromJson for BlockHeadingId

pub enum BlockHeadingLayout {
  Atx(BlockHeadingAtxLayout)
  Setext(BlockHeadingSetextLayout)
}
impl BlockHeadingLayout {
  from_json(Json, @json.JsonPath) -> Self!@json.JsonDecodeError
  to_json(Self) -> Json
  to_string(Self) -> String
}
impl Show for BlockHeadingLayout
impl ToJson for BlockHeadingLayout
impl @json.FromJson for BlockHeadingLayout

pub struct BlockHeadingSetextLayout {
  pub leading_indent : Int
  pub trailing_blanks : String
  pub underline_indent : Int
  pub underline_count : Node[Int]
  pub underline_blanks : String
}
impl BlockHeadingSetextLayout {
  from_json(Json, @json.JsonPath) -> Self!@json.JsonDecodeError
  to_json(Self) -> Json
  to_string(Self) -> String
}
impl Show for BlockHeadingSetextLayout
impl ToJson for BlockHeadingSetextLayout
impl @json.FromJson for BlockHeadingSetextLayout

pub type BlockLine Node[String]
impl BlockLine {
  list_text_loc(@list.T[Self]) -> @cmark_base.TextLoc
  to_string(Self) -> String
}

pub struct BlockList {
  pub ty : @cmark_base.ListType
  pub tight : Bool
  pub items : @list.T[Node[ListItem]]
}
impl BlockList {
  from_json(Json, @json.JsonPath) -> Self!@json.JsonDecodeError
  map_items(Self, (ListItem) -> ListItem) -> Self
  normalize_items(Self) -> Self
  to_json(Self) -> Json
  to_string(Self) -> String
}
impl Show for BlockList
impl ToJson for BlockList
impl @json.FromJson for BlockList

pub struct BlockParagraph {
  pub leading_indent : Int
  pub inline : Inline
  pub trailing_blanks : String
}
impl BlockParagraph {
  from_json(Json, @json.JsonPath) -> Self!@json.JsonDecodeError
  new(leading_indent~ : Int = .., trailing_blanks~ : String = .., Inline) -> Self
  to_json(Self) -> Json
  to_string(Self) -> String
}
impl Show for BlockParagraph
impl ToJson for BlockParagraph
impl @json.FromJson for BlockParagraph

pub struct BlockQuote {
  pub indent : Int
  pub block : Block
}
impl BlockQuote {
  from_json(Json, @json.JsonPath) -> Self!@json.JsonDecodeError
  map_block(Self, (Block) -> Block) -> Self
  new(indent~ : Int = .., Block) -> Self
  normalize_block(Self) -> Self
  to_json(Self) -> Json
  to_string(Self) -> String
}
impl Show for BlockQuote
impl ToJson for BlockQuote
impl @json.FromJson for BlockQuote

type BlockStruct
impl BlockStruct {
  to_json(Self) -> Json
  to_string(Self) -> String
}
impl Show for BlockStruct
impl ToJson for BlockStruct

pub struct BlockThematicBreak {
  pub indent : Int
  pub layout : String
}
impl BlockThematicBreak {
  from_json(Json, @json.JsonPath) -> Self!@json.JsonDecodeError
  new(indent~ : Int = .., layout~ : String = ..) -> Self
  to_json(Self) -> Json
  to_string(Self) -> String
}
impl Show for BlockThematicBreak
impl ToJson for BlockThematicBreak
impl @json.FromJson for BlockThematicBreak

type Closer
impl Closer {
  compare(Self, Self) -> Int
  hash_combine(Self, Hasher) -> Unit
  op_equal(Self, Self) -> Bool
  to_json(Self) -> Json
  to_string(Self) -> String
}
impl Compare for Closer
impl Eq for Closer
impl Hash for Closer
impl Show for Closer
impl ToJson for Closer

type CloserIndex
impl CloserIndex {
  to_json(Self) -> Json
  to_string(Self) -> String
}
impl Show for CloserIndex
impl ToJson for CloserIndex

pub struct CodeBlock {
  pub layout : CodeBlockLayout
  pub info_string : Node[String]?
  pub code : @list.T[Node[String]]
}
impl CodeBlock {
  from_json(Json, @json.JsonPath) -> Self!@json.JsonDecodeError
  language_of_info_string(String) -> (String, String)?
  make_fence(Self) -> (Char, Int)
  new(layout~ : CodeBlockLayout = .., info_string~ : Node[String]? = .., @list.T[Node[String]]) -> Self
  to_json(Self) -> Json
  to_string(Self) -> String
}
impl Show for CodeBlock
impl ToJson for CodeBlock
impl @json.FromJson for CodeBlock

pub struct CodeBlockFencedLayout {
  pub indent : Int
  pub opening_fence : Node[String]
  pub closing_fence : Node[String]?
}
impl CodeBlockFencedLayout {
  default() -> Self
  from_json(Json, @json.JsonPath) -> Self!@json.JsonDecodeError
  to_json(Self) -> Json
  to_string(Self) -> String
}
impl Show for CodeBlockFencedLayout
impl ToJson for CodeBlockFencedLayout
impl @json.FromJson for CodeBlockFencedLayout

pub enum CodeBlockLayout {
  Indented
  Fenced(CodeBlockFencedLayout)
}
impl CodeBlockLayout {
  from_json(Json, @json.JsonPath) -> Self!@json.JsonDecodeError
  to_json(Self) -> Json
  to_string(Self) -> String
}
impl Show for CodeBlockLayout
impl ToJson for CodeBlockLayout
impl @json.FromJson for CodeBlockLayout

type CodeBlockStruct
impl CodeBlockStruct {
  to_json(Self) -> Json
  to_string(Self) -> String
}
impl Show for CodeBlockStruct
impl ToJson for CodeBlockStruct

pub struct Doc {
  pub nl : String
  pub block : Block
  pub defs : @sorted_map.T[String, LabelDef]
}
impl Doc {
  empty() -> Self
  from_string(defs~ : @sorted_map.T[String, LabelDef] = .., resolver~ : (LabelContext) -> Label? = .., nested_links~ : Bool = .., heading_auto_ids~ : Bool = .., layout~ : Bool = .., locs~ : Bool = .., file~ : String = .., strict~ : Bool = .., String) -> Self
  new(nl~ : String = .., defs~ : @sorted_map.T[String, LabelDef] = .., Block) -> Self
  to_json(Self) -> Json
  to_string(Self) -> String
}
impl Show for Doc
impl ToJson for Doc

type Fence
impl Fence {
  to_json(Self) -> Json
  to_string(Self) -> String
}
impl Show for Fence
impl ToJson for Fence

type FenceCodeBlockStruct
impl FenceCodeBlockStruct {
  to_json(Self) -> Json
  to_string(Self) -> String
}
impl Show for FenceCodeBlockStruct
impl ToJson for FenceCodeBlockStruct

pub struct Folder {
  pub inline_ext_default : (Folder[A], A, Inline) -> A!FolderError
  pub block_ext_default : (Folder[A], A, Block) -> A!FolderError
  pub inline : (Folder[A], A, Inline) -> FolderResult[A]
  pub block : (Folder[A], A, Block) -> FolderResult[A]
}
impl Folder {
  block_ext_none[A](Self[A], A, Block) -> A!FolderError
  fold_block[A](Self[A], A, Block) -> A!FolderError
  fold_doc[A](Self[A], A, Doc) -> A!FolderError
  fold_inline[A](Self[A], A, Inline) -> A!FolderError
  inline_ext_none[A](Self[A], A, Inline) -> A!FolderError
  new[A](inline_ext_default~ : (Self[A], A, Inline) -> A!FolderError = .., block_ext_default~ : (Self[A], A, Block) -> A!FolderError = .., inline~ : (Self[A], A, Inline) -> FolderResult[A] = .., block~ : (Self[A], A, Block) -> FolderResult[A] = ..) -> Self[A]
  none[A, B](Self[A], A, B) -> FolderResult[A]
  ret[A](A) -> FolderResult[A]
}

pub type! FolderError String
impl FolderError {
  to_string(Self) -> String
}
impl Show for FolderError

pub enum FolderResult {
  Default
  Fold(A)
}
impl FolderResult {
  op_equal[A : Eq](Self[A], Self[A]) -> Bool
  to_json[A : ToJson](Self[A]) -> Json
  to_string[A : Show](Self[A]) -> String
}
impl[A] Default for FolderResult[A]
impl[A : Eq] Eq for FolderResult[A]
impl[A : Show] Show for FolderResult[A]
impl[A : ToJson] ToJson for FolderResult[A]

pub struct Footnote {
  pub indent : Int
  pub label : Label
  pub defined_label : Label?
  pub block : Block
}
impl Footnote {
  from_json(Json, @json.JsonPath) -> Self!@json.JsonDecodeError
  map_block(Self, (Block) -> Block) -> Self
  new(indent~ : Int = .., defined_label? : Label?, Label, Block) -> Self
  normalize_block(Self) -> Self
  to_json(Self) -> Json
  to_string(Self) -> String
}
impl Show for Footnote
impl ToJson for Footnote
impl @json.FromJson for Footnote

type Heading
impl Heading {
  to_json(Self) -> Json
  to_string(Self) -> String
}
impl Show for Heading
impl ToJson for Heading

pub type HtmlBlock @list.T[Node[String]]
impl HtmlBlock {
  from_json(Json, @json.JsonPath) -> Self!@json.JsonDecodeError
  to_json(Self) -> Json
  to_string(Self) -> String
}
impl Show for HtmlBlock
impl ToJson for HtmlBlock
impl @json.FromJson for HtmlBlock

type HtmlBlockStruct
impl HtmlBlockStruct {
  to_json(Self) -> Json
  to_string(Self) -> String
}
impl Show for HtmlBlockStruct
impl ToJson for HtmlBlockStruct

type IndentedCodeLine
impl IndentedCodeLine {
  to_json(Self) -> Json
  to_string(Self) -> String
}
impl Show for IndentedCodeLine
impl ToJson for IndentedCodeLine

pub enum Inline {
  Autolink(Node[InlineAutolink])
  Break(Node[InlineBreak])
  CodeSpan(Node[InlineCodeSpan])
  Emphasis(Node[InlineEmphasis])
  Image(Node[InlineLink])
  Inlines(Node[@list.T[Inline]])
  Link(Node[InlineLink])
  RawHtml(Node[InlineRawHtml])
  StrongEmphasis(Node[InlineEmphasis])
  Text(Node[String])
  ExtStrikethrough(Node[InlineStrikethrough])
}
impl Inline {
  empty() -> Self
  from_json(Json, @json.JsonPath) -> Self!@json.JsonDecodeError
  id(Self, buf~ : @buffer.T = ..) -> String
  is_empty(Self) -> Bool
  meta(Self) -> @cmark_base.Meta
  normalize(Self) -> Self
  op_equal(Self, Self) -> Bool
  to_json(Self) -> Json
  to_plain_text(Self, break_on_soft~ : Bool) -> @list.T[@list.T[String]]
  to_string(Self) -> String
}
impl Eq for Inline
impl Show for Inline
impl ToJson for Inline
impl @json.FromJson for Inline

pub struct InlineAutolink {
  pub is_email : Bool
  pub link : Node[String]
}
impl InlineAutolink {
  from_json(Json, @json.JsonPath) -> Self!@json.JsonDecodeError
  new(Node[String]) -> Self
  op_equal(Self, Self) -> Bool
  to_json(Self) -> Json
  to_string(Self) -> String
}
impl Eq for InlineAutolink
impl Show for InlineAutolink
impl ToJson for InlineAutolink
impl @json.FromJson for InlineAutolink

pub struct InlineBreak {
  pub layout_before : Node[String]
  pub ty : InlineBreakType
  pub layout_after : Node[String]
}
impl InlineBreak {
  from_json(Json, @json.JsonPath) -> Self!@json.JsonDecodeError
  new(layout_before~ : Node[String] = .., layout_after~ : Node[String] = .., InlineBreakType) -> Self
  op_equal(Self, Self) -> Bool
  to_json(Self) -> Json
  to_string(Self) -> String
}
impl Eq for InlineBreak
impl Show for InlineBreak
impl ToJson for InlineBreak
impl @json.FromJson for InlineBreak

pub enum InlineBreakType {
  Hard
  Soft
}
impl InlineBreakType {
  compare(Self, Self) -> Int
  from_json(Json, @json.JsonPath) -> Self!@json.JsonDecodeError
  op_equal(Self, Self) -> Bool
  to_json(Self) -> Json
  to_string(Self) -> String
}
impl Compare for InlineBreakType
impl Eq for InlineBreakType
impl Show for InlineBreakType
impl ToJson for InlineBreakType
impl @json.FromJson for InlineBreakType

pub struct InlineCodeSpan {
  pub backticks : Int
  pub code_layout : @list.T[Tight]
}
impl InlineCodeSpan {
  code(Self) -> String
  from_json(Json, @json.JsonPath) -> Self!@json.JsonDecodeError
  from_string(meta~ : @cmark_base.Meta = .., String) -> Self
  new(backticks~ : Int, @list.T[Tight]) -> Self
  op_equal(Self, Self) -> Bool
  to_json(Self) -> Json
  to_string(Self) -> String
}
impl Eq for InlineCodeSpan
impl Show for InlineCodeSpan
impl ToJson for InlineCodeSpan
impl @json.FromJson for InlineCodeSpan

pub struct InlineEmphasis {
  pub delim : Char
  pub inline : Inline
}
impl InlineEmphasis {
  from_json(Json, @json.JsonPath) -> Self!@json.JsonDecodeError
  new(delim~ : Char = .., Inline) -> Self
  op_equal(Self, Self) -> Bool
  to_json(Self) -> Json
  to_string(Self) -> String
}
impl Eq for InlineEmphasis
impl Show for InlineEmphasis
impl ToJson for InlineEmphasis
impl @json.FromJson for InlineEmphasis

pub struct InlineLink {
  pub text : Inline
  pub reference : ReferenceKind
}
impl InlineLink {
  from_json(Json, @json.JsonPath) -> Self!@json.JsonDecodeError
  is_unsafe(String) -> Bool
  new(Inline, ReferenceKind) -> Self
  op_equal(Self, Self) -> Bool
  reference_definition(Self, @sorted_map.T[String, LabelDef]) -> LabelDef?
  referenced_label(Self) -> Label?
  to_json(Self) -> Json
  to_string(Self) -> String
}
impl Eq for InlineLink
impl Show for InlineLink
impl ToJson for InlineLink
impl @json.FromJson for InlineLink

pub type InlineRawHtml @list.T[Tight]
impl InlineRawHtml {
  from_json(Json, @json.JsonPath) -> Self!@json.JsonDecodeError
  op_equal(Self, Self) -> Bool
  to_json(Self) -> Json
  to_string(Self) -> String
}
impl Eq for InlineRawHtml
impl Show for InlineRawHtml
impl ToJson for InlineRawHtml
impl @json.FromJson for InlineRawHtml

pub type InlineStrikethrough Inline
impl InlineStrikethrough {
  from_json(Json, @json.JsonPath) -> Self!@json.JsonDecodeError
  op_equal(Self, Self) -> Bool
  to_json(Self) -> Json
  to_string(Self) -> String
}
impl Eq for InlineStrikethrough
impl Show for InlineStrikethrough
impl ToJson for InlineStrikethrough
impl @json.FromJson for InlineStrikethrough

pub struct Label {
  pub meta : @cmark_base.Meta
  pub key : String
  pub text : @list.T[Tight]
}
impl Label {
  compare(Self, Self) -> Int
  from_json(Json, @json.JsonPath) -> Self!@json.JsonDecodeError
  new(meta~ : @cmark_base.Meta = .., key~ : String, @list.T[Tight]) -> Self
  op_equal(Self, Self) -> Bool
  text_loc(Self) -> @cmark_base.TextLoc
  to_json(Self) -> Json
  to_string(Self) -> String
}
impl Show for Label
impl ToJson for Label
impl @json.FromJson for Label

pub enum LabelContext {
  Def(Label?, Label)
  Ref(LinkKind, Label, Label?)
}
impl LabelContext {
  default_resolver(Self) -> Label?
}

pub enum LabelDef {
  LinkDef(Node[LinkDefinition])
  FootnoteDef(Node[Footnote])
}
impl LabelDef {
  to_json(Self) -> Json
  to_string(Self) -> String
}
impl Show for LabelDef
impl ToJson for LabelDef

pub struct LinkDefinition {
  pub layout : LinkDefinitionLayout
  pub label : Label?
  pub defined_label : Label?
  pub dest : Node[String]?
  pub title : @list.T[Tight]?
}
impl LinkDefinition {
  from_json(Json, @json.JsonPath) -> Self!@json.JsonDecodeError
  new(layout~ : LinkDefinitionLayout = .., label~ : Label? = .., defined_label~ : Label? = .., dest~ : Node[String]? = .., title~ : @list.T[Tight]? = ..) -> Self
  op_equal(Self, Self) -> Bool
  to_json(Self) -> Json
  to_string(Self) -> String
}
impl Eq for LinkDefinition
impl Show for LinkDefinition
impl ToJson for LinkDefinition
impl @json.FromJson for LinkDefinition

pub struct LinkDefinitionLayout {
  pub indent : Int
  pub angled_dest : Bool
  pub before_dest : @list.T[Node[String]]
  pub after_dest : @list.T[Node[String]]
  pub title_open_delim : Char
  pub after_title : @list.T[Node[String]]
}
impl LinkDefinitionLayout {
  default() -> Self
  for_dest(String) -> Self
  from_json(Json, @json.JsonPath) -> Self!@json.JsonDecodeError
  op_equal(Self, Self) -> Bool
  to_json(Self) -> Json
  to_string(Self) -> String
}
impl Eq for LinkDefinitionLayout
impl Show for LinkDefinitionLayout
impl ToJson for LinkDefinitionLayout
impl @json.FromJson for LinkDefinitionLayout

pub enum LinkKind {
  Link
  Image
}

type ListBlockStruct
impl ListBlockStruct {
  to_json(Self) -> Json
  to_string(Self) -> String
}
impl Show for ListBlockStruct
impl ToJson for ListBlockStruct

pub struct ListItem {
  pub before_marker : Int
  pub marker : Node[String]
  pub after_marker : Int
  pub block : Block
  pub ext_task_marker : Node[Char]?
}
impl ListItem {
  from_json(Json, @json.JsonPath) -> Self!@json.JsonDecodeError
  map_block(Self, (Block) -> Block) -> Self
  new(before_marker~ : Int = .., marker~ : Node[String] = .., after_marker~ : Int = .., ext_task_marker~ : Node[Char]?, Block) -> Self
  normalize_block(Self) -> Self
  to_json(Self) -> Json
  to_string(Self) -> String
}
impl Show for ListItem
impl ToJson for ListItem
impl @json.FromJson for ListItem

type ListItemStruct
impl ListItemStruct {
  to_json(Self) -> Json
  to_string(Self) -> String
}
impl Show for ListItemStruct
impl ToJson for ListItemStruct

pub enum ListTaskStatus {
  Cancelled
  Checked
  Unchecked
  Other(Char)
}
impl ListTaskStatus {
  from_marker(Char) -> Self
}

pub struct Mapper {
  pub inline_ext_default : (Mapper, Inline) -> Inline?!MapperError
  pub block_ext_default : (Mapper, Block) -> Block?!MapperError
  pub inline : (Mapper, Inline) -> MapperResult[Inline]
  pub block : (Mapper, Block) -> MapperResult[Block]
}
impl Mapper {
  block_ext_none[A](Self, A) -> A?!MapperError
  delete[A]() -> MapperResult[A]
  inline_ext_none[A](Self, A) -> A?!MapperError
  map_block(Self, Block) -> Block?
  map_doc(Self, Doc) -> Doc
  map_inline(Self, Inline) -> Inline?
  new(inline_ext_default~ : (Self, Inline) -> Inline?!MapperError = .., block_ext_default~ : (Self, Block) -> Block?!MapperError = .., inline~ : (Self, Inline) -> MapperResult[Inline] = .., block~ : (Self, Block) -> MapperResult[Block] = ..) -> Self
  none[A](Self, A) -> MapperResult[A]
  ret[A](A) -> MapperResult[A]
}

pub type! MapperError String
impl MapperError {
  to_string(Self) -> String
}
impl Show for MapperError

pub enum MapperResult {
  Default
  Map(A?)
}
impl MapperResult {
  op_equal[A : Eq](Self[A], Self[A]) -> Bool
  to_json[A : ToJson](Self[A]) -> Json
  to_string[A : Show](Self[A]) -> String
}
impl[A] Default for MapperResult[A]
impl[A : Eq] Eq for MapperResult[A]
impl[A : Show] Show for MapperResult[A]
impl[A : ToJson] ToJson for MapperResult[A]

pub struct Node {
  pub v : A
  pub meta : @cmark_base.Meta
}
impl Node {
  empty(meta~ : @cmark_base.Meta = ..) -> Self[String]
  map[A, B](Self[A], (A) -> B) -> Self[B]
  new[A](A, meta~ : @cmark_base.Meta = ..) -> Self[A]
  op_equal[A : Eq](Self[A], Self[A]) -> Bool
}
impl[A : Eq] Eq for Node[A]
impl[A : Show] Show for Node[A]
impl[A : ToJson] ToJson for Node[A]
impl[A : @json.FromJson] @json.FromJson for Node[A]

type Paragraph
impl Paragraph {
  to_json(Self) -> Json
  to_string(Self) -> String
}
impl Show for Paragraph
impl ToJson for Paragraph

type Parser
impl Parser {
  to_string(Self) -> String
}
impl Show for Parser

pub enum ReferenceKind {
  Inline(Node[LinkDefinition])
  Ref(ReferenceLayout, Label, Label)
}
impl ReferenceKind {
  from_json(Json, @json.JsonPath) -> Self!@json.JsonDecodeError
  op_equal(Self, Self) -> Bool
  to_json(Self) -> Json
  to_string(Self) -> String
}
impl Eq for ReferenceKind
impl Show for ReferenceKind
impl ToJson for ReferenceKind
impl @json.FromJson for ReferenceKind

pub enum ReferenceLayout {
  Collapsed
  Full
  Shortcut
}
impl ReferenceLayout {
  from_json(Json, @json.JsonPath) -> Self!@json.JsonDecodeError
  op_equal(Self, Self) -> Bool
  to_json(Self) -> Json
  to_string(Self) -> String
}
impl Eq for ReferenceLayout
impl Show for ReferenceLayout
impl ToJson for ReferenceLayout
impl @json.FromJson for ReferenceLayout

type Setext
impl Setext {
  to_json(Self) -> Json
  to_string(Self) -> String
}
impl Show for Setext
impl ToJson for Setext

type StartColResult
impl StartColResult {
  from_json(Json, @json.JsonPath) -> Self!@json.JsonDecodeError
  to_json(Self) -> Json
  to_string(Self) -> String
}
impl Show for StartColResult
impl ToJson for StartColResult
impl @json.FromJson for StartColResult

pub struct Table {
  pub indent : Int
  pub col_count : Int
  pub rows : @list.T[(Node[TableRow], String)]
}
impl Table {
  from_json(Json, @json.JsonPath) -> Self!@json.JsonDecodeError
  new(indent~ : Int = .., @list.T[(Node[TableRow], String)]) -> Self
  parse_sep_row(@list.T[(Inline, (String, String))]) -> @list.T[Node[(TableAlign?, Int)]]?
  to_json(Self) -> Json
  to_string(Self) -> String
}
impl Show for Table
impl ToJson for Table
impl @json.FromJson for Table

pub enum TableAlign {
  Left
  Center
  Right
}
impl TableAlign {
  from_json(Json, @json.JsonPath) -> Self!@json.JsonDecodeError
  to_json(Self) -> Json
  to_string(Self) -> String
}
impl Show for TableAlign
impl ToJson for TableAlign
impl @json.FromJson for TableAlign

pub enum TableRow {
  Header(@list.T[(Inline, (String, String))])
  Sep(@list.T[Node[(TableAlign?, Int)]])
  Data(@list.T[(Inline, (String, String))])
}
impl TableRow {
  from_json(Json, @json.JsonPath) -> Self!@json.JsonDecodeError
  to_json(Self) -> Json
  to_string(Self) -> String
}
impl Show for TableRow
impl ToJson for TableRow
impl @json.FromJson for TableRow

pub struct Tight {
  pub blanks : String
  pub node : Node[String]
}
impl Tight {
  empty(meta~ : @cmark_base.Meta = ..) -> Self
  from_json(Json, @json.JsonPath) -> Self!@json.JsonDecodeError
  list_text_loc(@list.T[Self]) -> @cmark_base.TextLoc
  op_equal(Self, Self) -> Bool
  to_json(Self) -> Json
  to_string(Self) -> String
}
impl Eq for Tight
impl Show for Tight
impl ToJson for Tight
impl @json.FromJson for Tight

type Token
impl Token {
  to_json(Self) -> Json
  to_string(Self) -> String
}
impl Show for Token
impl ToJson for Token

type TokenBackticks
impl TokenBackticks {
  to_json(Self) -> Json
  to_string(Self) -> String
}
impl Show for TokenBackticks
impl ToJson for TokenBackticks

type TokenEmphasisMarks
impl TokenEmphasisMarks {
  to_json(Self) -> Json
  to_string(Self) -> String
}
impl Show for TokenEmphasisMarks
impl ToJson for TokenEmphasisMarks

type TokenInline
impl TokenInline {
  to_json(Self) -> Json
  to_string(Self) -> String
}
impl Show for TokenInline
impl ToJson for TokenInline

type TokenLinkStart
impl TokenLinkStart {
  to_json(Self) -> Json
  to_string(Self) -> String
}
impl Show for TokenLinkStart
impl ToJson for TokenLinkStart

type TokenMathSpanMarks
impl TokenMathSpanMarks {
  to_json(Self) -> Json
  to_string(Self) -> String
}
impl Show for TokenMathSpanMarks
impl ToJson for TokenMathSpanMarks

type TokenNewline
impl TokenNewline {
  to_json(Self) -> Json
  to_string(Self) -> String
}
impl Show for TokenNewline
impl ToJson for TokenNewline

type TokenStart
impl TokenStart {
  to_json(Self) -> Json
  to_string(Self) -> String
}
impl Show for TokenStart
impl ToJson for TokenStart

type TokenStrikethroughMarks
impl TokenStrikethroughMarks {
  to_json(Self) -> Json
  to_string(Self) -> String
}
impl Show for TokenStrikethroughMarks
impl ToJson for TokenStrikethroughMarks

// Type aliases
pub typealias Blanks = String

pub typealias BlanksNode = Node[String]

pub typealias BlockBlankLine = String

pub typealias BlockLineBlank = Node[String]

pub typealias Count = Int

pub typealias FilterMap[A] = A?

pub typealias FoldFn[A, B] = (Folder[B], B, A) -> B!FolderError

pub typealias FolderFn[A, B] = (Folder[B], B, A) -> FolderResult[B]

pub typealias InlineText = String

pub typealias LabelDefs = @sorted_map.T[String, LabelDef]

pub typealias LabelKey = String

pub typealias LabelMap[V] = @sorted_map.T[String, V]

pub typealias LabelResolverFn = (LabelContext) -> Label?

pub typealias ListItemBlock = ListItem

pub typealias MapFn[A] = (Mapper, A) -> A?!MapperError

pub typealias MapperFn[A] = (Mapper, A) -> MapperResult[A]

pub typealias StringNode = Node[String]

pub typealias TableCellLayout = (String, String)

pub typealias TableSep = (TableAlign?, Int)

// Traits

